// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: glob 1`] = `
{
  "description": "Efficiently finds files matching specific glob patterns (e.g., \`src/**/*.ts\`, \`**/*.md\`), returning absolute paths sorted by modification time (newest first). Ideal for quickly locating files based on their name or path structure, especially in large codebases.",
  "name": "glob",
  "parametersJsonSchema": {
    "properties": {
      "case_sensitive": {
        "description": "Optional: Whether the search should be case-sensitive. Defaults to false.",
        "type": "boolean",
      },
      "dir_path": {
        "description": "Optional: The absolute path to the directory to search within. If omitted, searches the root directory.",
        "type": "string",
      },
      "pattern": {
        "description": "The glob pattern to match against (e.g., '**/*.py', 'docs/*.md').",
        "type": "string",
      },
      "respect_gemini_ignore": {
        "description": "Optional: Whether to respect .geminiignore patterns when finding files. Defaults to true.",
        "type": "boolean",
      },
      "respect_git_ignore": {
        "description": "Optional: Whether to respect .gitignore patterns when finding files. Only available in git repositories. Defaults to true.",
        "type": "boolean",
      },
    },
    "required": [
      "pattern",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: google_web_search 1`] = `
{
  "description": "Performs a web search using Google Search (via the Gemini API) and returns the results. This tool is useful for finding information on the internet based on a query.",
  "name": "google_web_search",
  "parametersJsonSchema": {
    "properties": {
      "query": {
        "description": "The search query to find information on the web.",
        "type": "string",
      },
    },
    "required": [
      "query",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: grep_search 1`] = `
{
  "description": "Searches for a regular expression pattern within file contents. Max 100 matches.",
  "name": "grep_search",
  "parametersJsonSchema": {
    "properties": {
      "dir_path": {
        "description": "Optional: The absolute path to the directory to search within. If omitted, searches the current working directory.",
        "type": "string",
      },
      "exclude_pattern": {
        "description": "Optional: A regular expression pattern to exclude from the search results. If a line matches both the pattern and the exclude_pattern, it will be omitted.",
        "type": "string",
      },
      "include": {
        "description": "Optional: A glob pattern to filter which files are searched (e.g., '*.js', '*.{ts,tsx}', 'src/**'). If omitted, searches all files (respecting potential global ignores).",
        "type": "string",
      },
      "max_matches_per_file": {
        "description": "Optional: Maximum number of matches to return per file. Use this to prevent being overwhelmed by repetitive matches in large files.",
        "minimum": 1,
        "type": "integer",
      },
      "names_only": {
        "description": "Optional: If true, only the file paths of the matches will be returned, without the line content or line numbers. This is useful for gathering a list of files.",
        "type": "boolean",
      },
      "pattern": {
        "description": "The regular expression (regex) pattern to search for within file contents (e.g., 'function\\s+myFunction', 'import\\s+\\{.*\\}\\s+from\\s+.*').",
        "type": "string",
      },
      "total_max_matches": {
        "description": "Optional: Maximum number of total matches to return. Use this to limit the overall size of the response. Defaults to 100 if omitted.",
        "minimum": 1,
        "type": "integer",
      },
    },
    "required": [
      "pattern",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: grep_search_ripgrep 1`] = `
{
  "description": "Searches for a regular expression pattern within file contents.",
  "name": "grep_search",
  "parametersJsonSchema": {
    "properties": {
      "after": {
        "description": "Show this many lines after each match (equivalent to grep -A). Defaults to 0 if omitted.",
        "minimum": 0,
        "type": "integer",
      },
      "before": {
        "description": "Show this many lines before each match (equivalent to grep -B). Defaults to 0 if omitted.",
        "minimum": 0,
        "type": "integer",
      },
      "case_sensitive": {
        "description": "If true, search is case-sensitive. Defaults to false (ignore case) if omitted.",
        "type": "boolean",
      },
      "context": {
        "description": "Show this many lines of context around each match (equivalent to grep -C). Defaults to 0 if omitted.",
        "type": "integer",
      },
      "dir_path": {
        "description": "Directory or file to search. Directories are searched recursively. Relative paths are resolved against current working directory. Defaults to current working directory ('.') if omitted.",
        "type": "string",
      },
      "exclude_pattern": {
        "description": "Optional: A regular expression pattern to exclude from the search results. If a line matches both the pattern and the exclude_pattern, it will be omitted.",
        "type": "string",
      },
      "fixed_strings": {
        "description": "If true, treats the \`pattern\` as a literal string instead of a regular expression. Defaults to false (basic regex) if omitted.",
        "type": "boolean",
      },
      "include": {
        "description": "Glob pattern to filter files (e.g., '*.ts', 'src/**'). Recommended for large repositories to reduce noise. Defaults to all files if omitted.",
        "type": "string",
      },
      "max_matches_per_file": {
        "description": "Optional: Maximum number of matches to return per file. Use this to prevent being overwhelmed by repetitive matches in large files.",
        "minimum": 1,
        "type": "integer",
      },
      "names_only": {
        "description": "Optional: If true, only the file paths of the matches will be returned, without the line content or line numbers. This is useful for gathering a list of files.",
        "type": "boolean",
      },
      "no_ignore": {
        "description": "If true, searches all files including those usually ignored (like in .gitignore, build/, dist/, etc). Defaults to false if omitted.",
        "type": "boolean",
      },
      "pattern": {
        "description": "The pattern to search for. By default, treated as a Rust-flavored regular expression. Use '\\b' for precise symbol matching (e.g., '\\bMatchMe\\b').",
        "type": "string",
      },
      "total_max_matches": {
        "description": "Optional: Maximum number of total matches to return. Use this to limit the overall size of the response. Defaults to 100 if omitted.",
        "minimum": 1,
        "type": "integer",
      },
    },
    "required": [
      "pattern",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: list_directory 1`] = `
{
  "description": "Lists the names of files and subdirectories directly within a specified directory path. Can optionally ignore entries matching provided glob patterns.",
  "name": "list_directory",
  "parametersJsonSchema": {
    "properties": {
      "dir_path": {
        "description": "The path to the directory to list",
        "type": "string",
      },
      "file_filtering_options": {
        "description": "Optional: Whether to respect ignore patterns from .gitignore or .geminiignore",
        "properties": {
          "respect_gemini_ignore": {
            "description": "Optional: Whether to respect .geminiignore patterns when listing files. Defaults to true.",
            "type": "boolean",
          },
          "respect_git_ignore": {
            "description": "Optional: Whether to respect .gitignore patterns when listing files. Only available in git repositories. Defaults to true.",
            "type": "boolean",
          },
        },
        "type": "object",
      },
      "ignore": {
        "description": "List of glob patterns to ignore",
        "items": {
          "type": "string",
        },
        "type": "array",
      },
    },
    "required": [
      "dir_path",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: read_file 1`] = `
{
  "description": "Reads and returns the content of a specified file. If the file is large, the content will be truncated. The tool's response will clearly indicate if truncation has occurred and will provide details on how to read more of the file using the 'offset' and 'limit' parameters. Handles text, images (PNG, JPG, GIF, WEBP, SVG, BMP), audio files (MP3, WAV, AIFF, AAC, OGG, FLAC), and PDF files. For text files, it can read specific line ranges.",
  "name": "read_file",
  "parametersJsonSchema": {
    "properties": {
      "file_path": {
        "description": "The path to the file to read.",
        "type": "string",
      },
      "limit": {
        "description": "Optional: For text files, maximum number of lines to read. Use with 'offset' to paginate through large files. If omitted, reads the entire file (if feasible, up to a default limit).",
        "type": "number",
      },
      "offset": {
        "description": "Optional: For text files, the 0-based line number to start reading from. Requires 'limit' to be set. Use for paginating through large files.",
        "type": "number",
      },
    },
    "required": [
      "file_path",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: replace 1`] = `
{
  "description": "Replaces text within a file. By default, replaces a single occurrence, but can replace multiple occurrences when \`expected_replacements\` is specified. This tool requires providing significant context around the change to ensure precise targeting. Always use the read_file tool to examine the file's current content before attempting a text replacement.
      
      The user has the ability to modify the \`new_string\` content. If modified, this will be stated in the response.
      
      Expectation for required parameters:
      1. \`old_string\` MUST be the exact literal text to replace (including all whitespace, indentation, newlines, and surrounding code etc.).
      2. \`new_string\` MUST be the exact literal text to replace \`old_string\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic and that \`old_string\` and \`new_string\` are different.
      3. \`instruction\` is the detailed instruction of what needs to be changed. It is important to Make it specific and detailed so developers or large language models can understand what needs to be changed and perform the changes on their own if necessary. 
      4. NEVER escape \`old_string\` or \`new_string\`, that would break the exact literal text requirement.
      **Important:** If ANY of the above are not satisfied, the tool will fail. CRITICAL for \`old_string\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail.
      5. Prefer to break down complex and long changes into multiple smaller atomic calls to this tool. Always check the content of the file after changes or not finding a string to match.
      **Multiple replacements:** Set \`expected_replacements\` to the number of occurrences you want to replace. The tool will replace ALL occurrences that match \`old_string\` exactly. Ensure the number of replacements matches your expectation.",
  "name": "replace",
  "parametersJsonSchema": {
    "properties": {
      "expected_replacements": {
        "description": "Number of replacements expected. Defaults to 1 if not specified. Use when you want to replace multiple occurrences.",
        "minimum": 1,
        "type": "number",
      },
      "file_path": {
        "description": "The path to the file to modify.",
        "type": "string",
      },
      "instruction": {
        "description": "A clear, semantic instruction for the code change, acting as a high-quality prompt for an expert LLM assistant. It must be self-contained and explain the goal of the change.

A good instruction should concisely answer:
1.  WHY is the change needed? (e.g., "To fix a bug where users can be null...")
2.  WHERE should the change happen? (e.g., "...in the 'renderUserProfile' function...")
3.  WHAT is the high-level change? (e.g., "...add a null check for the 'user' object...")
4.  WHAT is the desired outcome? (e.g., "...so that it displays a loading spinner instead of crashing.")

**GOOD Example:** "In the 'calculateTotal' function, correct the sales tax calculation by updating the 'taxRate' constant from 0.05 to 0.075 to reflect the new regional tax laws."

**BAD Examples:**
- "Change the text." (Too vague)
- "Fix the bug." (Doesn't explain the bug or the fix)
- "Replace the line with this new line." (Brittle, just repeats the other parameters)
",
        "type": "string",
      },
      "new_string": {
        "description": "The exact literal text to replace \`old_string\` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic.",
        "type": "string",
      },
      "old_string": {
        "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail.",
        "type": "string",
      },
    },
    "required": [
      "file_path",
      "instruction",
      "old_string",
      "new_string",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: run_shell_command 1`] = `
{
  "description": "This tool executes a given shell command as \`bash -c <command>\`. To run a command in the background, set the \`is_background\` parameter to true. Do NOT use \`&\` to background commands. Command is executed as a subprocess that leads its own process group. Command process group can be terminated as \`kill -- -PGID\` or signaled as \`kill -s SIGNAL -- -PGID\`.

      Efficiency Guidelines:
      - Quiet Flags: Always prefer silent or quiet flags (e.g., \`npm install --silent\`, \`git --no-pager\`) to reduce output volume while still capturing necessary information.
      - Pagination: Always disable terminal pagination to ensure commands terminate (e.g., use \`git --no-pager\`, \`systemctl --no-pager\`, or set \`PAGER=cat\`).

      The following information is returned:

      Output: Combined stdout/stderr. Can be \`(empty)\` or partial on error and for any unwaited background processes.
      Exit Code: Only included if non-zero (command failed).
      Error: Only included if a process-level error occurred (e.g., spawn failure).
      Signal: Only included if process was terminated by a signal.
      Background PIDs: Only included if background processes were started.
      Process Group PGID: Only included if available.",
  "name": "run_shell_command",
  "parametersJsonSchema": {
    "properties": {
      "command": {
        "description": "Exact bash command to execute as \`bash -c <command>\`",
        "type": "string",
      },
      "description": {
        "description": "Brief description of the command for the user. Be specific and concise. Ideally a single sentence. Can be up to 3 sentences for clarity. No line breaks.",
        "type": "string",
      },
      "dir_path": {
        "description": "(OPTIONAL) The path of the directory to run the command in. If not provided, the project root directory is used. Must be a directory within the workspace and must already exist.",
        "type": "string",
      },
      "is_background": {
        "description": "Set to true if this command should be run in the background (e.g. for long-running servers or watchers). The command will be started, allowed to run for a brief moment to check for immediate errors, and then moved to the background.",
        "type": "boolean",
      },
    },
    "required": [
      "command",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-2.5-pro > snapshot for tool: write_file 1`] = `
{
  "description": "Writes content to a specified file in the local filesystem.

      The user has the ability to modify \`content\`. If modified, this will be stated in the response.",
  "name": "write_file",
  "parametersJsonSchema": {
    "properties": {
      "content": {
        "description": "The content to write to the file.",
        "type": "string",
      },
      "file_path": {
        "description": "The path to the file to write to.",
        "type": "string",
      },
    },
    "required": [
      "file_path",
      "content",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: glob 1`] = `
{
  "description": "Efficiently finds files matching specific glob patterns (e.g., \`src/**/*.ts\`, \`**/*.md\`), returning absolute paths sorted by modification time (newest first). Ideal for quickly locating files based on their name or path structure, especially in large codebases.",
  "name": "glob",
  "parametersJsonSchema": {
    "properties": {
      "case_sensitive": {
        "description": "Optional: Whether the search should be case-sensitive. Defaults to false.",
        "type": "boolean",
      },
      "dir_path": {
        "description": "Optional: The absolute path to the directory to search within. If omitted, searches the root directory.",
        "type": "string",
      },
      "pattern": {
        "description": "The glob pattern to match against (e.g., '**/*.py', 'docs/*.md').",
        "type": "string",
      },
      "respect_gemini_ignore": {
        "description": "Optional: Whether to respect .geminiignore patterns when finding files. Defaults to true.",
        "type": "boolean",
      },
      "respect_git_ignore": {
        "description": "Optional: Whether to respect .gitignore patterns when finding files. Only available in git repositories. Defaults to true.",
        "type": "boolean",
      },
    },
    "required": [
      "pattern",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: google_web_search 1`] = `
{
  "description": "Performs a web search using Google Search (via the Gemini API) and returns the results. This tool is useful for finding information on the internet based on a query.",
  "name": "google_web_search",
  "parametersJsonSchema": {
    "properties": {
      "query": {
        "description": "The search query to find information on the web.",
        "type": "string",
      },
    },
    "required": [
      "query",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: grep_search 1`] = `
{
  "description": "Searches for a regular expression pattern within file contents. Max 100 matches.",
  "name": "grep_search",
  "parametersJsonSchema": {
    "properties": {
      "dir_path": {
        "description": "Optional: The absolute path to the directory to search within. If omitted, searches the current working directory.",
        "type": "string",
      },
      "exclude_pattern": {
        "description": "Optional: A regular expression pattern to exclude from the search results. If a line matches both the pattern and the exclude_pattern, it will be omitted.",
        "type": "string",
      },
      "include": {
        "description": "Optional: A glob pattern to filter which files are searched (e.g., '*.js', '*.{ts,tsx}', 'src/**'). If omitted, searches all files (respecting potential global ignores).",
        "type": "string",
      },
      "max_matches_per_file": {
        "description": "Optional: Maximum number of matches to return per file. Use this to prevent being overwhelmed by repetitive matches in large files.",
        "minimum": 1,
        "type": "integer",
      },
      "names_only": {
        "description": "Optional: If true, only the file paths of the matches will be returned, without the line content or line numbers. This is useful for gathering a list of files.",
        "type": "boolean",
      },
      "pattern": {
        "description": "The regular expression (regex) pattern to search for within file contents (e.g., 'function\\s+myFunction', 'import\\s+\\{.*\\}\\s+from\\s+.*').",
        "type": "string",
      },
      "total_max_matches": {
        "description": "Optional: Maximum number of total matches to return. Use this to limit the overall size of the response. Defaults to 100 if omitted.",
        "minimum": 1,
        "type": "integer",
      },
    },
    "required": [
      "pattern",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: grep_search_ripgrep 1`] = `
{
  "description": "Searches for a regular expression pattern within file contents.",
  "name": "grep_search",
  "parametersJsonSchema": {
    "properties": {
      "after": {
        "description": "Show this many lines after each match (equivalent to grep -A). Defaults to 0 if omitted.",
        "minimum": 0,
        "type": "integer",
      },
      "before": {
        "description": "Show this many lines before each match (equivalent to grep -B). Defaults to 0 if omitted.",
        "minimum": 0,
        "type": "integer",
      },
      "case_sensitive": {
        "description": "If true, search is case-sensitive. Defaults to false (ignore case) if omitted.",
        "type": "boolean",
      },
      "context": {
        "description": "Show this many lines of context around each match (equivalent to grep -C). Defaults to 0 if omitted.",
        "type": "integer",
      },
      "dir_path": {
        "description": "Directory or file to search. Directories are searched recursively. Relative paths are resolved against current working directory. Defaults to current working directory ('.') if omitted.",
        "type": "string",
      },
      "exclude_pattern": {
        "description": "Optional: A regular expression pattern to exclude from the search results. If a line matches both the pattern and the exclude_pattern, it will be omitted.",
        "type": "string",
      },
      "fixed_strings": {
        "description": "If true, treats the \`pattern\` as a literal string instead of a regular expression. Defaults to false (basic regex) if omitted.",
        "type": "boolean",
      },
      "include": {
        "description": "Glob pattern to filter files (e.g., '*.ts', 'src/**'). Recommended for large repositories to reduce noise. Defaults to all files if omitted.",
        "type": "string",
      },
      "max_matches_per_file": {
        "description": "Optional: Maximum number of matches to return per file. Use this to prevent being overwhelmed by repetitive matches in large files.",
        "minimum": 1,
        "type": "integer",
      },
      "names_only": {
        "description": "Optional: If true, only the file paths of the matches will be returned, without the line content or line numbers. This is useful for gathering a list of files.",
        "type": "boolean",
      },
      "no_ignore": {
        "description": "If true, searches all files including those usually ignored (like in .gitignore, build/, dist/, etc). Defaults to false if omitted.",
        "type": "boolean",
      },
      "pattern": {
        "description": "The pattern to search for. By default, treated as a Rust-flavored regular expression. Use '\\b' for precise symbol matching (e.g., '\\bMatchMe\\b').",
        "type": "string",
      },
      "total_max_matches": {
        "description": "Optional: Maximum number of total matches to return. Use this to limit the overall size of the response. Defaults to 100 if omitted.",
        "minimum": 1,
        "type": "integer",
      },
    },
    "required": [
      "pattern",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: list_directory 1`] = `
{
  "description": "Lists the names of files and subdirectories directly within a specified directory path. Can optionally ignore entries matching provided glob patterns.",
  "name": "list_directory",
  "parametersJsonSchema": {
    "properties": {
      "dir_path": {
        "description": "The path to the directory to list",
        "type": "string",
      },
      "file_filtering_options": {
        "description": "Optional: Whether to respect ignore patterns from .gitignore or .geminiignore",
        "properties": {
          "respect_gemini_ignore": {
            "description": "Optional: Whether to respect .geminiignore patterns when listing files. Defaults to true.",
            "type": "boolean",
          },
          "respect_git_ignore": {
            "description": "Optional: Whether to respect .gitignore patterns when listing files. Only available in git repositories. Defaults to true.",
            "type": "boolean",
          },
        },
        "type": "object",
      },
      "ignore": {
        "description": "List of glob patterns to ignore",
        "items": {
          "type": "string",
        },
        "type": "array",
      },
    },
    "required": [
      "dir_path",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: read_file 1`] = `
{
  "description": "Reads and returns the content of a specified file. If the file is large, the content will be truncated. The tool's response will clearly indicate if truncation has occurred and will provide details on how to read more of the file using the 'offset' and 'limit' parameters. Handles text, images (PNG, JPG, GIF, WEBP, SVG, BMP), audio files (MP3, WAV, AIFF, AAC, OGG, FLAC), and PDF files. For text files, it can read specific line ranges.",
  "name": "read_file",
  "parametersJsonSchema": {
    "properties": {
      "file_path": {
        "description": "The path to the file to read.",
        "type": "string",
      },
      "limit": {
        "description": "Optional: For text files, maximum number of lines to read. Use with 'offset' to paginate through large files. If omitted, reads the entire file (if feasible, up to a default limit).",
        "type": "number",
      },
      "offset": {
        "description": "Optional: For text files, the 0-based line number to start reading from. Requires 'limit' to be set. Use for paginating through large files.",
        "type": "number",
      },
    },
    "required": [
      "file_path",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: replace 1`] = `
{
  "description": "Replaces text within a file. By default, replaces a single occurrence, but can replace multiple occurrences when \`expected_replacements\` is specified. This tool requires providing significant context around the change to ensure precise targeting. Always use the read_file tool to examine the file's current content before attempting a text replacement.
      
      The user has the ability to modify the \`new_string\` content. If modified, this will be stated in the response.
      
      Expectation for required parameters:
      1. \`old_string\` MUST be the exact literal text to replace (including all whitespace, indentation, newlines, and surrounding code etc.).
      2. \`new_string\` MUST be the exact literal text to replace \`old_string\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic and that \`old_string\` and \`new_string\` are different.
      3. \`instruction\` is the detailed instruction of what needs to be changed. It is important to Make it specific and detailed so developers or large language models can understand what needs to be changed and perform the changes on their own if necessary. 
      4. NEVER escape \`old_string\` or \`new_string\`, that would break the exact literal text requirement.
      **Important:** If ANY of the above are not satisfied, the tool will fail. CRITICAL for \`old_string\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail.
      5. Prefer to break down complex and long changes into multiple smaller atomic calls to this tool. Always check the content of the file after changes or not finding a string to match.
      **Multiple replacements:** Set \`expected_replacements\` to the number of occurrences you want to replace. The tool will replace ALL occurrences that match \`old_string\` exactly. Ensure the number of replacements matches your expectation.",
  "name": "replace",
  "parametersJsonSchema": {
    "properties": {
      "expected_replacements": {
        "description": "Number of replacements expected. Defaults to 1 if not specified. Use when you want to replace multiple occurrences.",
        "minimum": 1,
        "type": "number",
      },
      "file_path": {
        "description": "The path to the file to modify.",
        "type": "string",
      },
      "instruction": {
        "description": "A clear, semantic instruction for the code change, acting as a high-quality prompt for an expert LLM assistant. It must be self-contained and explain the goal of the change.

A good instruction should concisely answer:
1.  WHY is the change needed? (e.g., "To fix a bug where users can be null...")
2.  WHERE should the change happen? (e.g., "...in the 'renderUserProfile' function...")
3.  WHAT is the high-level change? (e.g., "...add a null check for the 'user' object...")
4.  WHAT is the desired outcome? (e.g., "...so that it displays a loading spinner instead of crashing.")

**GOOD Example:** "In the 'calculateTotal' function, correct the sales tax calculation by updating the 'taxRate' constant from 0.05 to 0.075 to reflect the new regional tax laws."

**BAD Examples:**
- "Change the text." (Too vague)
- "Fix the bug." (Doesn't explain the bug or the fix)
- "Replace the line with this new line." (Brittle, just repeats the other parameters)
",
        "type": "string",
      },
      "new_string": {
        "description": "The exact literal text to replace \`old_string\` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic.",
        "type": "string",
      },
      "old_string": {
        "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail.",
        "type": "string",
      },
    },
    "required": [
      "file_path",
      "instruction",
      "old_string",
      "new_string",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: run_shell_command 1`] = `
{
  "description": "This tool executes a given shell command as \`bash -c <command>\`. To run a command in the background, set the \`is_background\` parameter to true. Do NOT use \`&\` to background commands. Command is executed as a subprocess that leads its own process group. Command process group can be terminated as \`kill -- -PGID\` or signaled as \`kill -s SIGNAL -- -PGID\`.

      Efficiency Guidelines:
      - Quiet Flags: Always prefer silent or quiet flags (e.g., \`npm install --silent\`, \`git --no-pager\`) to reduce output volume while still capturing necessary information.
      - Pagination: Always disable terminal pagination to ensure commands terminate (e.g., use \`git --no-pager\`, \`systemctl --no-pager\`, or set \`PAGER=cat\`).

      The following information is returned:

      Output: Combined stdout/stderr. Can be \`(empty)\` or partial on error and for any unwaited background processes.
      Exit Code: Only included if non-zero (command failed).
      Error: Only included if a process-level error occurred (e.g., spawn failure).
      Signal: Only included if process was terminated by a signal.
      Background PIDs: Only included if background processes were started.
      Process Group PGID: Only included if available.",
  "name": "run_shell_command",
  "parametersJsonSchema": {
    "properties": {
      "command": {
        "description": "Exact bash command to execute as \`bash -c <command>\`",
        "type": "string",
      },
      "description": {
        "description": "Brief description of the command for the user. Be specific and concise. Ideally a single sentence. Can be up to 3 sentences for clarity. No line breaks.",
        "type": "string",
      },
      "dir_path": {
        "description": "(OPTIONAL) The path of the directory to run the command in. If not provided, the project root directory is used. Must be a directory within the workspace and must already exist.",
        "type": "string",
      },
      "is_background": {
        "description": "Set to true if this command should be run in the background (e.g. for long-running servers or watchers). The command will be started, allowed to run for a brief moment to check for immediate errors, and then moved to the background.",
        "type": "boolean",
      },
    },
    "required": [
      "command",
    ],
    "type": "object",
  },
}
`;

exports[`coreTools snapshots for specific models > Model: gemini-3-pro-preview > snapshot for tool: write_file 1`] = `
{
  "description": "Writes content to a specified file in the local filesystem.

      The user has the ability to modify \`content\`. If modified, this will be stated in the response.",
  "name": "write_file",
  "parametersJsonSchema": {
    "properties": {
      "content": {
        "description": "The content to write to the file.",
        "type": "string",
      },
      "file_path": {
        "description": "The path to the file to write to.",
        "type": "string",
      },
    },
    "required": [
      "file_path",
      "content",
    ],
    "type": "object",
  },
}
`;
